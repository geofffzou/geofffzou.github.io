<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>SVG Outline as Track on Leaflet</title>

<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
/>
<link
  rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"
/>

<style>
  body { margin:0; font-family:Arial,sans-serif; }
  #controls { padding:10px; background:#f4f4f4; }
  #map { height:90vh; width:100%; }
</style>
</head>
<body>

<div id="controls">
  Draw a rectangle and upload an SVG to convert its outline into a track.<br><br>
  <input type="file" id="svgUpload" accept=".svg" />
</div>

<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/svg-path-parser/1.1.1/svg-path-parser.min.js"></script>

<script>
const map = L.map('map').setView([40.7128, -74.0060], 13);

// Base map
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

// Draw control
const drawnItems = new L.FeatureGroup();
map.addLayer(drawnItems);

const drawControl = new L.Control.Draw({
  draw: { rectangle: true, polygon:false, polyline:false, circle:false, marker:false, circlemarker:false },
  edit: { featureGroup: drawnItems, remove:true }
});
map.addControl(drawControl);

let selectedBounds = null;
let currentTrack = null;

// Rectangle creation
map.on(L.Draw.Event.CREATED, function(event){
  drawnItems.clearLayers(); // only one rectangle
  const layer = event.layer;
  drawnItems.addLayer(layer);
  selectedBounds = layer.getBounds();
});

// File upload
document.getElementById('svgUpload').addEventListener('change', function(e){
  const file = e.target.files[0];
  if (!file || !selectedBounds) {
    alert("Please draw a rectangle first.");
    return;
  }

  const reader = new FileReader();
  reader.onload = function(event){
    const svgText = event.target.result;

    // Parse SVG
    const parser = new DOMParser();
    const svgDoc = parser.parseFromString(svgText, "image/svg+xml");
    const paths = svgDoc.querySelectorAll('path');

    if (paths.length === 0) {
      alert("No <path> found in SVG.");
      return;
    }

    const svgWidth = svgDoc.documentElement.viewBox.baseVal.width || svgDoc.documentElement.width.baseVal.value;
    const svgHeight = svgDoc.documentElement.viewBox.baseVal.height || svgDoc.documentElement.height.baseVal.value;

    // Map bounds
    const sw = selectedBounds.getSouthWest();
    const ne = selectedBounds.getNorthEast();
    const latRange = ne.lat - sw.lat;
    const lngRange = ne.lng - sw.lng;

    if(currentTrack) map.removeLayer(currentTrack);

    const trackPoints = [];

    paths.forEach(pathEl => {
      const d = pathEl.getAttribute('d');
      const commands = window.svgPathParser.parseSVG(d);

      commands.forEach(cmd => {
        if (cmd.x !== undefined && cmd.y !== undefined) {
          // Map SVG coords to bounds
          const lat = sw.lat + (1 - cmd.y/svgHeight) * latRange; // invert Y
          const lng = sw.lng + (cmd.x/svgWidth) * lngRange;
          trackPoints.push([lat, lng]);
        }
      });
    });

    currentTrack = L.polyline(trackPoints, {color:'red'}).addTo(map);
    map.fitBounds(selectedBounds);
  };
  reader.readAsText(file);
});
</script>

</body>
</html>
