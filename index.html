<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>SVG Outline as Smooth Track on Leaflet</title>

<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
/>
<link
  rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"
/>

<style>
  body { margin:0; font-family:Arial,sans-serif; }
  #controls { padding:10px; background:#f4f4f4; }
  #map { height:90vh; width:100%; }
</style>
</head>
<body>

<div id="controls">
  Draw a rectangle and upload an SVG to convert its outline into a smooth track.<br><br>
  <input type="file" id="svgUpload" accept=".svg" />
</div>

<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/svg-path-parser/1.1.1/svg-path-parser.min.js"></script>

<script>
// Utility: sample cubic Bézier
function cubicBezier(p0, p1, p2, p3, t){
  const x = Math.pow(1-t,3)*p0[0] + 3*Math.pow(1-t,2)*t*p1[0] + 3*(1-t)*Math.pow(t,2)*p2[0] + Math.pow(t,3)*p3[0];
  const y = Math.pow(1-t,3)*p0[1] + 3*Math.pow(1-t,2)*t*p1[1] + 3*(1-t)*Math.pow(t,2)*p2[1] + Math.pow(t,3)*p3[1];
  return [x,y];
}

// Map initialization
const map = L.map('map').setView([40.7128, -74.0060], 13);

// Base map
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

// Draw rectangle
const drawnItems = new L.FeatureGroup();
map.addLayer(drawnItems);

const drawControl = new L.Control.Draw({
  draw: { rectangle: true, polygon:false, polyline:false, circle:false, marker:false, circlemarker:false },
  edit: { featureGroup: drawnItems, remove:true }
});
map.addControl(drawControl);

let selectedBounds = null;
let currentTrack = null;

// Rectangle creation
map.on(L.Draw.Event.CREATED, function(event){
  drawnItems.clearLayers();
  const layer = event.layer;
  drawnItems.addLayer(layer);
  selectedBounds = layer.getBounds();
});

// Handle file upload
document.getElementById('svgUpload').addEventListener('change', function(e){
  const file = e.target.files[0];
  if(!file || !selectedBounds){
    alert("Please draw a rectangle first.");
    return;
  }

  const reader = new FileReader();
  reader.onload = function(event){
    const svgText = event.target.result;

    const parser = new DOMParser();
    const svgDoc = parser.parseFromString(svgText, "image/svg+xml");
    const paths = svgDoc.querySelectorAll('path');

    if(paths.length === 0){
      alert("No <path> found in SVG.");
      return;
    }

    const svgWidth = svgDoc.documentElement.viewBox.baseVal.width || svgDoc.documentElement.width.baseVal.value;
    const svgHeight = svgDoc.documentElement.viewBox.baseVal.height || svgDoc.documentElement.height.baseVal.value;

    const sw = selectedBounds.getSouthWest();
    const ne = selectedBounds.getNorthEast();
    const latRange = ne.lat - sw.lat;
    const lngRange = ne.lng - sw.lng;

    if(currentTrack) map.removeLayer(currentTrack);

    const trackPoints = [];

    paths.forEach(pathEl => {
      const d = pathEl.getAttribute('d');
      const commands = window.svgPathParser.parseSVG(d);

      let curr = [0,0];
      commands.forEach(cmd => {
        switch(cmd.code){
          case 'M':
            curr = [cmd.x, cmd.y];
            trackPoints.push([sw.lat + (1 - curr[1]/svgHeight)*latRange, sw.lng + (curr[0]/svgWidth)*lngRange]);
            break;

          case 'L':
            curr = [cmd.x, cmd.y];
            trackPoints.push([sw.lat + (1 - curr[1]/svgHeight)*latRange, sw.lng + (curr[0]/svgWidth)*lngRange]);
            break;

          case 'C':
            // cubic Bézier: sample 10 points
            const p0 = curr;
            const p1 = [cmd.x1, cmd.y1];
            const p2 = [cmd.x2, cmd.y2];
            const p3 = [cmd.x, cmd.y];
            const steps = 10;
            for(let i=1;i<=steps;i++){
              const [x,y] = cubicBezier(p0,p1,p2,p3,i/steps);
              trackPoints.push([sw.lat + (1 - y/svgHeight)*latRange, sw.lng + (x/svgWidth)*lngRange]);
            }
            curr = p3;
            break;

          case 'Z': 
            // close path
            break;
        }
      });
    });

    currentTrack = L.polyline(trackPoints, {color:'red'}).addTo(map);
    map.fitBounds(selectedBounds);
  };

  reader.readAsText(file);
});
</script>
</body>
</html>
